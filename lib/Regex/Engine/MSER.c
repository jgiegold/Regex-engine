/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.11 from the
 * contents of MSER.xs. Do not edit this file, edit MSER.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "lib/PDL/Regex/MSER.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       /* Gets pointer to perl var holding core structure */

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif

typedef struct pdl_MSER_const_scores_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_y_n;PDL_Long  __inc_scores_n1;PDL_Long  __n_size;PDL_Long  __n1_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_const_scores_struct;

void pdl_MSER_const_scores_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__privtrans->__n1_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * scores_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * scores_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * scores_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * scores_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * scores_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * scores_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * scores_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * scores_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * scores_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * scores_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * scores_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * scores_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scores_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scores_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"y","scores"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_const_scores";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_const_scores:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n1_size <= 1) __privtrans->__n1_size = 1;
   }
   if(__privtrans->__n1_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n1_size == 1)) {
      __privtrans->__n1_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n1_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_const_scores:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n1_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_scores_n1 = 0; else
		 __privtrans->__inc_scores_n1 = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_const_scores_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    pdl_MSER_const_scores_struct *__copy = malloc(sizeof(pdl_MSER_const_scores_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_scores_n1=__copy->__inc_scores_n1;__copy->__n_size=__privtrans->__n_size;__copy->__n1_size=__privtrans->__n1_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_const_scores_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * scores_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * scores_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * scores_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * scores_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * scores_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * scores_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * scores_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * scores_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * scores_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * scores_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * scores_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * scores_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scores_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scores_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_const_scores_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_MSER_const_scores_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_MSER_const_scores_vtable = {
		0,0, 1, 2, pdl_MSER_const_scores_vtable_flags,
		pdl_MSER_const_scores_redodims, pdl_MSER_const_scores_readdata, NULL,
		pdl_MSER_const_scores_free,NULL,NULL,pdl_MSER_const_scores_copy,NULL,
		sizeof(pdl_MSER_const_scores_struct),"pdl_MSER_const_scores_vtable",
		NULL
	 };

typedef struct pdl__MSER_const_min_idx_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_const_min_idx_struct;

void pdl__MSER_const_min_idx_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"y","best_index","best_avg","best_var"};
		static int __realdims[] = {1,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_const_min_idx";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_const_min_idx:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[0],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_const_min_idx_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    pdl__MSER_const_min_idx_struct *__copy = malloc(sizeof(pdl__MSER_const_min_idx_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_const_min_idx_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * best_avg_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * best_avg_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * best_var_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * best_var_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Short * best_avg_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * best_avg_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * best_var_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * best_var_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Ushort * best_avg_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * best_avg_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * best_var_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * best_var_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * best_avg_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * best_avg_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * best_var_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * best_var_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_LongLong * best_avg_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * best_avg_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * best_var_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * best_var_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Float * best_avg_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * best_avg_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * best_var_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * best_var_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * best_avg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * best_avg_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * best_var_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * best_var_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_const_min_idx_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl__MSER_const_min_idx_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl__MSER_const_min_idx_vtable = {
		0,0, 1, 4, pdl__MSER_const_min_idx_vtable_flags,
		pdl__MSER_const_min_idx_redodims, pdl__MSER_const_min_idx_readdata, NULL,
		pdl__MSER_const_min_idx_free,NULL,NULL,pdl__MSER_const_min_idx_copy,NULL,
		sizeof(pdl__MSER_const_min_idx_struct),"pdl__MSER_const_min_idx_vtable",
		NULL
	 };


#if 0
my $skip = <<'SKIP';
#endif

/*

#if 0
  "Skipped embedded POD."
#endif
#line 1755 "lib/PDL/Regex/MSER.xs"

*/

int MSER_linear_score_calculator(double * xs, double * ys, double * scores
		, int N, double * best_slope, double * best_intercept
		, double * best_variance) {

/*

#if 0
  "Skipped embedded POD."
#endif
#line 1802 "lib/PDL/Regex/MSER.xs"

*/

	double S_x, S_y, S_xy, S_xx, S_yy, y0, s, x, y, score, lowest_score, n;
	int i, best_index;
	
	/* These are accumulators, so initialize them to zero */
	S_x = S_y = S_xx = S_xy = S_yy = 0;

	/* Compute the sums for the first three points */
	for(i = 0; i < 3; i++) {
		x = (xs ? xs[i] : i);
		y = ys[i];
		S_x += x;
		S_y += y;
		S_xy += x * y;
		S_xx += x * x;
		S_yy += y * y;
	}
	
/*

#if 0
  "Skipped embedded POD."
#endif
#line 1879 "lib/PDL/Regex/MSER.xs"

*/

	n = 3;
	
	/* Compute the first y-intercept */
	y0 = (S_y/S_x - S_xy/S_xx)
					/
		  (n/S_x - S_x/S_xx);
	
	/* Store the intercept, if requested */
	if (best_intercept) best_intercept[0] = y0;

/*

#if 0
  "Skipped embedded POD."
#endif
#line 1903 "lib/PDL/Regex/MSER.xs"

*/

	/* Compute the first slope */
	s = S_y / S_x - n * y0 / S_x;
	/* Store the result if requested */
	if(best_slope) best_slope[0] = s;
	
/*

#if 0
  "Skipped embedded POD."
#endif
#line 1933 "lib/PDL/Regex/MSER.xs"

*/
	
	/* Compute the first score and store it, if appropriate */
	score = (n*y0*y0 + 2*y0*s*S_x - 2*y0*S_y + s*s*S_xx - 2*s*S_xy + S_yy)
			/ (n - 2) / (n - 2);
	
	lowest_score = score;
	best_index = i;
	
	if (scores) scores[0] = score;
	if (best_variance) best_variance[0] = score * (n - 2);

/*

#if 0
  "Skipped embedded POD."
#endif
#line 1956 "lib/PDL/Regex/MSER.xs"

*/

	/* Loop over the remaining points */
	for(; i < N; i++) {
		x = (xs ? xs[i] : i);
		y = ys[i];
		S_x += x;
		S_y += y;
		S_xy += x * y;
		S_xx += x * x;
		S_yy += y * y;

		n = i + 1;
		
		/* Here are those equations again
		 ----------------------------
		|       S_y/S_x - S_xy/S_xx  |
		| y0 = --------------------- |
		|        n/S_x - S_x/S_xx    |
		 ----------------------------
		*/
		y0 = (S_y / S_x - S_xy / S_xx)
			/ (n / S_x - S_x / S_xx);
		/*
		 ------------------------------
		| s = S_y / S_x - n * y0 / S_x |
		 ------------------------------
		*/
		s = S_y / S_x - n * y0 / S_x;
		
		/* Compute the score and store it, as appropriate */
		/*
		 -----------------------------------------------------------------
		|    n*y0^2 + 2*y0*s*S_x - 2*y0*S_y + s^2*S_xx - 2*s*S_xy + S_yy  |
		| = ------------------------------------------------------------- |
		|                         ( n - 2 )^2                             |
		 -----------------------------------------------------------------
		*/
		score = ( n*y0*y0 + 2*y0*s*S_x - 2*y0*S_y + s*s*S_xx - 2*s*S_xy + S_yy)
				/ (n - 2) / (n - 2);
		
		if (score < lowest_score) {
			lowest_score = score;
			best_index = i;
			if(best_slope) best_slope[0] = s;
			if (best_intercept) best_intercept[0] = y0;
			if (best_variance) best_variance[0] = score * (n - 2);
		}
		
		if (scores) scores[i-2] = score;
	}
	
	return best_index;
}

#if 0
SKIP
#endif

typedef struct pdl_MSER_linear_scores_no_x_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_ys_n;PDL_Long  __inc_score_n2;PDL_Long  __n_size;PDL_Long  __n2_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_linear_scores_no_x_struct;

void pdl_MSER_linear_scores_no_x_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__privtrans->__n2_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;

__privtrans->__n2_size = __privtrans->pdls[0]->dims[0] - 2;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ys","score"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_linear_scores_no_x";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n2_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_score_n2 = 0; else
		 __privtrans->__inc_score_n2 = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_linear_scores_no_x_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    pdl_MSER_linear_scores_no_x_struct *__copy = malloc(sizeof(pdl_MSER_linear_scores_no_x_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_ys_n=__copy->__inc_ys_n;__privtrans->__inc_score_n2=__copy->__inc_score_n2;__copy->__n_size=__privtrans->__n_size;__copy->__n2_size=__privtrans->__n2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_linear_scores_no_x_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];ys_datap += __offsp[0];
score_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;


		MSER_linear_score_calculator(0, ys_datap, score_datap, __privtrans->__n_size, 0, 0, 0);
	
}	/* THREADLOOPEND */
	 ys_datap += __tinc0_0;
score_datap += __tinc0_1;

	 } ys_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
score_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} ys_datap -= __tinc1_0 *
     				  __tdims1;score_datap -= __tinc1_1 *
     				  __tdims1;
 ys_datap -= __offsp[0];
score_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_linear_scores_no_x_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_MSER_linear_scores_no_x_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_MSER_linear_scores_no_x_vtable = {
		0,0, 1, 2, pdl_MSER_linear_scores_no_x_vtable_flags,
		pdl_MSER_linear_scores_no_x_redodims, pdl_MSER_linear_scores_no_x_readdata, NULL,
		pdl_MSER_linear_scores_no_x_free,NULL,NULL,pdl_MSER_linear_scores_no_x_copy,NULL,
		sizeof(pdl_MSER_linear_scores_no_x_struct),"pdl_MSER_linear_scores_no_x_vtable",
		NULL
	 };

typedef struct pdl_MSER_linear_scores_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_xs_n;PDL_Long  __inc_ys_n;PDL_Long  __inc_score_n2;PDL_Long  __n_size;PDL_Long  __n2_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_linear_scores_struct;

void pdl_MSER_linear_scores_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__privtrans->__n2_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;

__privtrans->__n2_size = __privtrans->pdls[1]->dims[0] - 2;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xs","ys","score"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_linear_scores";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n2_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xs_n = 0; else
		 __privtrans->__inc_xs_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_score_n2 = 0; else
		 __privtrans->__inc_score_n2 = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_linear_scores_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    pdl_MSER_linear_scores_struct *__copy = malloc(sizeof(pdl_MSER_linear_scores_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xs_n=__copy->__inc_xs_n;__privtrans->__inc_ys_n=__copy->__inc_ys_n;__privtrans->__inc_score_n2=__copy->__inc_score_n2;__copy->__n_size=__privtrans->__n_size;__copy->__n2_size=__privtrans->__n2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_linear_scores_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];xs_datap += __offsp[0];
ys_datap += __offsp[1];
score_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;


		MSER_linear_score_calculator(xs_datap, ys_datap, score_datap, __privtrans->__n_size, 0, 0, 0);
	
}	/* THREADLOOPEND */
	 xs_datap += __tinc0_0;
ys_datap += __tinc0_1;
score_datap += __tinc0_2;

	 } xs_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ys_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
score_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} xs_datap -= __tinc1_0 *
     				  __tdims1;ys_datap -= __tinc1_1 *
     				  __tdims1;score_datap -= __tinc1_2 *
     				  __tdims1;
 xs_datap -= __offsp[0];
ys_datap -= __offsp[1];
score_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_linear_scores_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_MSER_linear_scores_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_MSER_linear_scores_vtable = {
		0,0, 2, 3, pdl_MSER_linear_scores_vtable_flags,
		pdl_MSER_linear_scores_redodims, pdl_MSER_linear_scores_readdata, NULL,
		pdl_MSER_linear_scores_free,NULL,NULL,pdl_MSER_linear_scores_copy,NULL,
		sizeof(pdl_MSER_linear_scores_struct),"pdl_MSER_linear_scores_vtable",
		NULL
	 };

typedef struct pdl__MSER_linear_min_idx_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_xs_n;PDL_Long  __inc_ys_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_linear_min_idx_struct;

void pdl__MSER_linear_min_idx_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"xs","ys","best_index","slope","intercept","variance"};
		static int __realdims[] = {1,1,0,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_linear_min_idx";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[2]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xs_n = 0; else
		 __privtrans->__inc_xs_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_linear_min_idx_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    pdl__MSER_linear_min_idx_struct *__copy = malloc(sizeof(pdl__MSER_linear_min_idx_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xs_n=__copy->__inc_xs_n;__privtrans->__inc_ys_n=__copy->__inc_ys_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_linear_min_idx_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * slope_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * slope_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * intercept_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * intercept_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * variance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * variance_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xs_datap += __offsp[0];
ys_datap += __offsp[1];
best_index_datap += __offsp[2];
slope_datap += __offsp[3];
intercept_datap += __offsp[4];
variance_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;


		(best_index_datap)[0] /* ACCESS() */  = MSER_linear_score_calculator(xs_datap, ys_datap, 0, __privtrans->__n_size
				, slope_datap, intercept_datap, variance_datap);
	
}	/* THREADLOOPEND */
	 xs_datap += __tinc0_0;
ys_datap += __tinc0_1;
best_index_datap += __tinc0_2;
slope_datap += __tinc0_3;
intercept_datap += __tinc0_4;
variance_datap += __tinc0_5;

	 } xs_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ys_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_index_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
slope_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
intercept_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
variance_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xs_datap -= __tinc1_0 *
     				  __tdims1;ys_datap -= __tinc1_1 *
     				  __tdims1;best_index_datap -= __tinc1_2 *
     				  __tdims1;slope_datap -= __tinc1_3 *
     				  __tdims1;intercept_datap -= __tinc1_4 *
     				  __tdims1;variance_datap -= __tinc1_5 *
     				  __tdims1;
 xs_datap -= __offsp[0];
ys_datap -= __offsp[1];
best_index_datap -= __offsp[2];
slope_datap -= __offsp[3];
intercept_datap -= __offsp[4];
variance_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_linear_min_idx_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl__MSER_linear_min_idx_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl__MSER_linear_min_idx_vtable = {
		0,0, 2, 6, pdl__MSER_linear_min_idx_vtable_flags,
		pdl__MSER_linear_min_idx_redodims, pdl__MSER_linear_min_idx_readdata, NULL,
		pdl__MSER_linear_min_idx_free,NULL,NULL,pdl__MSER_linear_min_idx_copy,NULL,
		sizeof(pdl__MSER_linear_min_idx_struct),"pdl__MSER_linear_min_idx_vtable",
		NULL
	 };

typedef struct pdl__MSER_linear_min_idx_no_x_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_ys_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_linear_min_idx_no_x_struct;

void pdl__MSER_linear_min_idx_no_x_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"ys","best_index","slope","intercept","variance"};
		static int __realdims[] = {1,0,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_linear_min_idx_no_x";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_linear_min_idx_no_x_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    pdl__MSER_linear_min_idx_no_x_struct *__copy = malloc(sizeof(pdl__MSER_linear_min_idx_no_x_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_ys_n=__copy->__inc_ys_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_linear_min_idx_no_x_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * slope_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * slope_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * intercept_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * intercept_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * variance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * variance_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];ys_datap += __offsp[0];
best_index_datap += __offsp[1];
slope_datap += __offsp[2];
intercept_datap += __offsp[3];
variance_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;


		(best_index_datap)[0] /* ACCESS() */  = MSER_linear_score_calculator(0, ys_datap, 0, __privtrans->__n_size
				, slope_datap, intercept_datap, variance_datap);
	
}	/* THREADLOOPEND */
	 ys_datap += __tinc0_0;
best_index_datap += __tinc0_1;
slope_datap += __tinc0_2;
intercept_datap += __tinc0_3;
variance_datap += __tinc0_4;

	 } ys_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
slope_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
intercept_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
variance_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} ys_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;slope_datap -= __tinc1_2 *
     				  __tdims1;intercept_datap -= __tinc1_3 *
     				  __tdims1;variance_datap -= __tinc1_4 *
     				  __tdims1;
 ys_datap -= __offsp[0];
best_index_datap -= __offsp[1];
slope_datap -= __offsp[2];
intercept_datap -= __offsp[3];
variance_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_linear_min_idx_no_x_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl__MSER_linear_min_idx_no_x_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl__MSER_linear_min_idx_no_x_vtable = {
		0,0, 1, 5, pdl__MSER_linear_min_idx_no_x_vtable_flags,
		pdl__MSER_linear_min_idx_no_x_redodims, pdl__MSER_linear_min_idx_no_x_readdata, NULL,
		pdl__MSER_linear_min_idx_no_x_free,NULL,NULL,pdl__MSER_linear_min_idx_no_x_copy,NULL,
		sizeof(pdl__MSER_linear_min_idx_no_x_struct),"pdl__MSER_linear_min_idx_no_x_vtable",
		NULL
	 };



#line 3155 "lib/PDL/Regex/MSER.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)    S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage        S_croak_xs_usage
#endif

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#line 3297 "lib/PDL/Regex/MSER.c"

XS_EUPXS(XS_PDL__Regex__MSER_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__Regex__MSER_set_debugging)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 3288 "lib/PDL/Regex/MSER.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 3313 "lib/PDL/Regex/MSER.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL__Regex__MSER_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__Regex__MSER_set_boundscheck)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 3297 "lib/PDL/Regex/MSER.xs"
       if (! 1)
         warn("Bounds checking is disabled for PDL::Regex::MSER");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 3336 "lib/PDL/Regex/MSER.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL_MSER_const_scores); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_MSER_const_scores)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3311 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *scores_SV;
  pdl  *y;
  pdl  *scores;
#line 3360 "lib/PDL/Regex/MSER.c"
#line 3320 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    y = PDL->SvPDLV(ST(0));
    scores = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    y = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       scores_SV = sv_newmortal();
       scores = PDL->null();
       PDL->SetSV_PDL(scores_SV,scores);
       if (bless_stash) scores_SV = sv_bless(scores_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       scores_SV = POPs;
       PUTBACK;
       scores = PDL->SvPDLV(scores_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_const_scores(y,scores) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_const_scores_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_const_scores_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((scores->state & PDL_NOMYDIMS) &&
		       scores->trans == NULL) && __privtrans->__datatype < scores->datatype) {
		 	__privtrans->__datatype = scores->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (scores->state & PDL_NOMYDIMS) && scores->trans == NULL ) {
	     scores->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != scores->datatype) {
	     scores = PDL->get_convertedpdl(scores,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = y;
__privtrans->pdls[1] = scores;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  scores->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = scores_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 3447 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL__MSER_const_min_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__MSER_const_min_idx)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3409 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *best_avg_SV;
  SV *best_var_SV;
  pdl  *y;
  pdl  *best_index;
  pdl  *best_avg;
  pdl  *best_var;
#line 3475 "lib/PDL/Regex/MSER.c"
#line 3422 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 4) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    y = PDL->SvPDLV(ST(0));
    best_index = PDL->SvPDLV(ST(1));
    best_avg = PDL->SvPDLV(ST(2));
    best_var = PDL->SvPDLV(ST(3));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 3;
    y = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_avg_SV = sv_newmortal();
       best_avg = PDL->null();
       PDL->SetSV_PDL(best_avg_SV,best_avg);
       if (bless_stash) best_avg_SV = sv_bless(best_avg_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_avg_SV = POPs;
       PUTBACK;
       best_avg = PDL->SvPDLV(best_avg_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_var_SV = sv_newmortal();
       best_var = PDL->null();
       PDL->SetSV_PDL(best_var_SV,best_var);
       if (bless_stash) best_var_SV = sv_bless(best_var_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_var_SV = POPs;
       PUTBACK;
       best_var = PDL->SvPDLV(best_var_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_const_min_idx(y,best_index,best_avg,best_var) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_const_min_idx_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_const_min_idx_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((best_avg->state & PDL_NOMYDIMS) &&
		       best_avg->trans == NULL) && __privtrans->__datatype < best_avg->datatype) {
		 	__privtrans->__datatype = best_avg->datatype;
		    }
if(!((best_var->state & PDL_NOMYDIMS) &&
		       best_var->trans == NULL) && __privtrans->__datatype < best_var->datatype) {
		 	__privtrans->__datatype = best_var->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (best_avg->state & PDL_NOMYDIMS) && best_avg->trans == NULL ) {
	     best_avg->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != best_avg->datatype) {
	     best_avg = PDL->get_convertedpdl(best_avg,__privtrans->__datatype);
	  }if( (best_var->state & PDL_NOMYDIMS) && best_var->trans == NULL ) {
	     best_var->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != best_var->datatype) {
	     best_var = PDL->get_convertedpdl(best_var,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = y;
__privtrans->pdls[1] = best_index;
__privtrans->pdls[2] = best_avg;
__privtrans->pdls[3] = best_var;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  best_avg->state |= PDL_BADVAL;
  best_var->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = best_avg_SV;
  ST(2) = best_var_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 3612 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_MSER_linear_scores_no_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_MSER_linear_scores_no_x)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3561 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *score_SV;
  pdl  *ys;
  pdl  *score;
#line 3636 "lib/PDL/Regex/MSER.c"
#line 3570 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    ys = PDL->SvPDLV(ST(0));
    score = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    ys = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       score_SV = sv_newmortal();
       score = PDL->null();
       PDL->SetSV_PDL(score_SV,score);
       if (bless_stash) score_SV = sv_bless(score_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       score_SV = POPs;
       PUTBACK;
       score = PDL->SvPDLV(score_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_linear_scores_no_x(ys,score) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_linear_scores_no_x_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_linear_scores_no_x_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((score->state & PDL_NOMYDIMS) &&
		       score->trans == NULL) && __privtrans->__datatype < score->datatype) {
		 	__privtrans->__datatype = score->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (score->state & PDL_NOMYDIMS) && score->trans == NULL ) {
	     score->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != score->datatype) {
	     score = PDL->get_convertedpdl(score,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ys;
__privtrans->pdls[1] = score;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  score->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = score_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 3717 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_MSER_linear_scores); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_MSER_linear_scores)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3653 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *score_SV;
  pdl  *xs;
  pdl  *ys;
  pdl  *score;
#line 3742 "lib/PDL/Regex/MSER.c"
#line 3663 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 3) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    score = PDL->SvPDLV(ST(2));
  }
  else if (items == 2) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       score_SV = sv_newmortal();
       score = PDL->null();
       PDL->SetSV_PDL(score_SV,score);
       if (bless_stash) score_SV = sv_bless(score_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       score_SV = POPs;
       PUTBACK;
       score = PDL->SvPDLV(score_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_linear_scores(xs,ys,score) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_linear_scores_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_linear_scores_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xs->state & PDL_BADVAL) > 0) || ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xs->datatype) {
		 	__privtrans->__datatype = xs->datatype;
		    }
if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((score->state & PDL_NOMYDIMS) &&
		       score->trans == NULL) && __privtrans->__datatype < score->datatype) {
		 	__privtrans->__datatype = score->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xs->datatype) {
	     xs = PDL->get_convertedpdl(xs,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (score->state & PDL_NOMYDIMS) && score->trans == NULL ) {
	     score->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != score->datatype) {
	     score = PDL->get_convertedpdl(score,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xs;
__privtrans->pdls[1] = ys;
__privtrans->pdls[2] = score;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  score->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = score_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 3831 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL__MSER_linear_min_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__MSER_linear_min_idx)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3754 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *slope_SV;
  SV *intercept_SV;
  SV *variance_SV;
  pdl  *xs;
  pdl  *ys;
  pdl  *best_index;
  pdl  *slope;
  pdl  *intercept;
  pdl  *variance;
#line 3862 "lib/PDL/Regex/MSER.c"
#line 3770 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 6) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    best_index = PDL->SvPDLV(ST(2));
    slope = PDL->SvPDLV(ST(3));
    intercept = PDL->SvPDLV(ST(4));
    variance = PDL->SvPDLV(ST(5));
  }
  else if (items == 2) { /* only input variables on stack, create outputs and temps */
    nreturn = 4;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       slope_SV = sv_newmortal();
       slope = PDL->null();
       PDL->SetSV_PDL(slope_SV,slope);
       if (bless_stash) slope_SV = sv_bless(slope_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       slope_SV = POPs;
       PUTBACK;
       slope = PDL->SvPDLV(slope_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       intercept_SV = sv_newmortal();
       intercept = PDL->null();
       PDL->SetSV_PDL(intercept_SV,intercept);
       if (bless_stash) intercept_SV = sv_bless(intercept_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       intercept_SV = POPs;
       PUTBACK;
       intercept = PDL->SvPDLV(intercept_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       variance_SV = sv_newmortal();
       variance = PDL->null();
       PDL->SetSV_PDL(variance_SV,variance);
       if (bless_stash) variance_SV = sv_bless(variance_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       variance_SV = POPs;
       PUTBACK;
       variance = PDL->SvPDLV(variance_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_linear_min_idx(xs,ys,best_index,slope,intercept,variance) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_linear_min_idx_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_linear_min_idx_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xs->state & PDL_BADVAL) > 0) || ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xs->datatype) {
		 	__privtrans->__datatype = xs->datatype;
		    }
if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((slope->state & PDL_NOMYDIMS) &&
		       slope->trans == NULL) && __privtrans->__datatype < slope->datatype) {
		 	__privtrans->__datatype = slope->datatype;
		    }
if(!((intercept->state & PDL_NOMYDIMS) &&
		       intercept->trans == NULL) && __privtrans->__datatype < intercept->datatype) {
		 	__privtrans->__datatype = intercept->datatype;
		    }
if(!((variance->state & PDL_NOMYDIMS) &&
		       variance->trans == NULL) && __privtrans->__datatype < variance->datatype) {
		 	__privtrans->__datatype = variance->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xs->datatype) {
	     xs = PDL->get_convertedpdl(xs,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (slope->state & PDL_NOMYDIMS) && slope->trans == NULL ) {
	     slope->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != slope->datatype) {
	     slope = PDL->get_convertedpdl(slope,__privtrans->__datatype);
	  }if( (intercept->state & PDL_NOMYDIMS) && intercept->trans == NULL ) {
	     intercept->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != intercept->datatype) {
	     intercept = PDL->get_convertedpdl(intercept,__privtrans->__datatype);
	  }if( (variance->state & PDL_NOMYDIMS) && variance->trans == NULL ) {
	     variance->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != variance->datatype) {
	     variance = PDL->get_convertedpdl(variance,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xs;
__privtrans->pdls[1] = ys;
__privtrans->pdls[2] = best_index;
__privtrans->pdls[3] = slope;
__privtrans->pdls[4] = intercept;
__privtrans->pdls[5] = variance;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  slope->state |= PDL_BADVAL;
  intercept->state |= PDL_BADVAL;
  variance->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = slope_SV;
  ST(2) = intercept_SV;
  ST(3) = variance_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 4028 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL__MSER_linear_min_idx_no_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__MSER_linear_min_idx_no_x)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 3938 "lib/PDL/Regex/MSER.xs"
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *slope_SV;
  SV *intercept_SV;
  SV *variance_SV;
  pdl  *ys;
  pdl  *best_index;
  pdl  *slope;
  pdl  *intercept;
  pdl  *variance;
#line 4058 "lib/PDL/Regex/MSER.c"
#line 3953 "lib/PDL/Regex/MSER.xs"
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 5) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    ys = PDL->SvPDLV(ST(0));
    best_index = PDL->SvPDLV(ST(1));
    slope = PDL->SvPDLV(ST(2));
    intercept = PDL->SvPDLV(ST(3));
    variance = PDL->SvPDLV(ST(4));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 4;
    ys = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       slope_SV = sv_newmortal();
       slope = PDL->null();
       PDL->SetSV_PDL(slope_SV,slope);
       if (bless_stash) slope_SV = sv_bless(slope_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       slope_SV = POPs;
       PUTBACK;
       slope = PDL->SvPDLV(slope_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       intercept_SV = sv_newmortal();
       intercept = PDL->null();
       PDL->SetSV_PDL(intercept_SV,intercept);
       if (bless_stash) intercept_SV = sv_bless(intercept_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       intercept_SV = POPs;
       PUTBACK;
       intercept = PDL->SvPDLV(intercept_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       variance_SV = sv_newmortal();
       variance = PDL->null();
       PDL->SetSV_PDL(variance_SV,variance);
       if (bless_stash) variance_SV = sv_bless(variance_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       variance_SV = POPs;
       PUTBACK;
       variance = PDL->SvPDLV(variance_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_linear_min_idx_no_x(ys,best_index,slope,intercept,variance) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_linear_min_idx_no_x_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_linear_min_idx_no_x_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((slope->state & PDL_NOMYDIMS) &&
		       slope->trans == NULL) && __privtrans->__datatype < slope->datatype) {
		 	__privtrans->__datatype = slope->datatype;
		    }
if(!((intercept->state & PDL_NOMYDIMS) &&
		       intercept->trans == NULL) && __privtrans->__datatype < intercept->datatype) {
		 	__privtrans->__datatype = intercept->datatype;
		    }
if(!((variance->state & PDL_NOMYDIMS) &&
		       variance->trans == NULL) && __privtrans->__datatype < variance->datatype) {
		 	__privtrans->__datatype = variance->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (slope->state & PDL_NOMYDIMS) && slope->trans == NULL ) {
	     slope->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != slope->datatype) {
	     slope = PDL->get_convertedpdl(slope,__privtrans->__datatype);
	  }if( (intercept->state & PDL_NOMYDIMS) && intercept->trans == NULL ) {
	     intercept->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != intercept->datatype) {
	     intercept = PDL->get_convertedpdl(intercept,__privtrans->__datatype);
	  }if( (variance->state & PDL_NOMYDIMS) && variance->trans == NULL ) {
	     variance->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != variance->datatype) {
	     variance = PDL->get_convertedpdl(variance,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ys;
__privtrans->pdls[1] = best_index;
__privtrans->pdls[2] = slope;
__privtrans->pdls[3] = intercept;
__privtrans->pdls[4] = variance;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  slope->state |= PDL_BADVAL;
  intercept->state |= PDL_BADVAL;
  variance->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = slope_SV;
  ST(2) = intercept_SV;
  ST(3) = variance_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 4216 "lib/PDL/Regex/MSER.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_PDL__Regex__MSER); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_PDL__Regex__MSER)
{
    dVAR; dXSARGS;
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#endif
    XS_VERSION_BOOTCHECK;

        (void)newXSproto_portable("PDL::Regex::MSER::set_debugging", XS_PDL__Regex__MSER_set_debugging, file, "$");
        (void)newXSproto_portable("PDL::Regex::MSER::set_boundscheck", XS_PDL__Regex__MSER_set_boundscheck, file, "$");
        (void)newXSproto_portable("PDL::MSER_const_scores", XS_PDL_MSER_const_scores, file, ";@");
        (void)newXSproto_portable("PDL::_MSER_const_min_idx", XS_PDL__MSER_const_min_idx, file, ";@");
        (void)newXSproto_portable("PDL::MSER_linear_scores_no_x", XS_PDL_MSER_linear_scores_no_x, file, ";@");
        (void)newXSproto_portable("PDL::MSER_linear_scores", XS_PDL_MSER_linear_scores, file, ";@");
        (void)newXSproto_portable("PDL::_MSER_linear_min_idx", XS_PDL__MSER_linear_min_idx, file, ";@");
        (void)newXSproto_portable("PDL::_MSER_linear_min_idx_no_x", XS_PDL__MSER_linear_min_idx_no_x, file, ";@");

    /* Initialisation Section */

#line 4112 "lib/PDL/Regex/MSER.xs"

   /* Get pointer to structure of core shared C routines */
   /* make sure PDL::Core is loaded */
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] PDL::Regex::MSER needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 4268 "lib/PDL/Regex/MSER.c"

    /* End of Initialisation Section */

#if (PERL_REVISION == 5 && PERL_VERSION >= 9)
  if (PL_unitcheckav)
       call_list(PL_scopestack_ix, PL_unitcheckav);
#endif
    XSRETURN_YES;
}

