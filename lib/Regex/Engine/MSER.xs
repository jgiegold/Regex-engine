
/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; /* Structure hold core C functions */
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       /* Gets pointer to perl var holding core structure */

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif

typedef struct pdl_MSER_const_scores_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_y_n;PDL_Long  __inc_scores_n1;PDL_Long  __n_size;PDL_Long  __n1_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_const_scores_struct;

void pdl_MSER_const_scores_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__privtrans->__n1_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * scores_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * scores_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * scores_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * scores_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * scores_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * scores_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * scores_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * scores_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * scores_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * scores_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * scores_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * scores_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scores_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scores_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;

__privtrans->__n1_size = __privtrans->pdls[0]->dims[0] - 1;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"y","scores"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_const_scores";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_const_scores:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n1_size <= 1) __privtrans->__n1_size = 1;
   }
   if(__privtrans->__n1_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n1_size == 1)) {
      __privtrans->__n1_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n1_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_const_scores:" "Wrong dims\n");
      }
   }
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n1_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_scores_n1 = 0; else
		 __privtrans->__inc_scores_n1 = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_const_scores_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    pdl_MSER_const_scores_struct *__copy = malloc(sizeof(pdl_MSER_const_scores_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_y_n=__copy->__inc_y_n;__privtrans->__inc_scores_n1=__copy->__inc_scores_n1;__copy->__n_size=__privtrans->__n_size;__copy->__n1_size=__privtrans->__n1_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_const_scores_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * scores_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * scores_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * scores_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * scores_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * scores_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * scores_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * scores_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * scores_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_LongLong * scores_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_LongLong * scores_physdatap = ((PDL_LongLong *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Float * scores_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Float * scores_physdatap = ((PDL_Float *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * scores_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * scores_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_scores_n1 = __privtrans->__inc_scores_n1;
register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, n_points;
		int i;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];y_datap += __offsp[0];
scores_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			for(i = 1; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* must omit spacing here thanks to PdlParObj.pm line 384 */
				(scores_datap)[0+(__inc_scores_n1*PP_INDTERM(__privtrans->__n1_size, i-1))] /* ACCESS() */ 
						= (S_yy - S_y * S_y / n_points) / i / n_points;
			}
			
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
scores_datap += __tinc0_1;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
scores_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;scores_datap -= __tinc1_1 *
     				  __tdims1;
 y_datap -= __offsp[0];
scores_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_const_scores_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_const_scores_struct *__privtrans = (pdl_MSER_const_scores_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_MSER_const_scores_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_MSER_const_scores_vtable = {
		0,0, 1, 2, pdl_MSER_const_scores_vtable_flags,
		pdl_MSER_const_scores_redodims, pdl_MSER_const_scores_readdata, NULL,
		pdl_MSER_const_scores_free,NULL,NULL,pdl_MSER_const_scores_copy,NULL,
		sizeof(pdl_MSER_const_scores_struct),"pdl_MSER_const_scores_vtable",
		NULL
	 };

typedef struct pdl__MSER_const_min_idx_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Long  __inc_y_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_const_min_idx_struct;

void pdl__MSER_const_min_idx_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    int __creating[4];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"y","best_index","best_avg","best_var"};
		static int __realdims[] = {1,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_const_min_idx";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_const_min_idx:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_y_n = 0; else
		 __privtrans->__inc_y_n = PDL_REPRINC(__privtrans->pdls[0],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_const_min_idx_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    pdl__MSER_const_min_idx_struct *__copy = malloc(sizeof(pdl__MSER_const_min_idx_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_y_n=__copy->__inc_y_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_const_min_idx_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_B: {
	PDL_Byte * y_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * y_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * best_avg_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * best_avg_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

	PDL_Byte * best_var_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Byte * best_var_physdatap = ((PDL_Byte *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_S: {
	PDL_Short * y_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * y_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Short * best_avg_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * best_avg_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

	PDL_Short * best_var_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Short * best_var_physdatap = ((PDL_Short *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_US: {
	PDL_Ushort * y_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * y_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Ushort * best_avg_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * best_avg_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

	PDL_Ushort * best_var_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Ushort * best_var_physdatap = ((PDL_Ushort *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_L: {
	PDL_Long * y_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * y_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * best_avg_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * best_avg_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * best_var_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * best_var_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_LL: {
	PDL_LongLong * y_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_LongLong * y_physdatap = ((PDL_LongLong *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_LongLong * best_avg_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_LongLong * best_avg_physdatap = ((PDL_LongLong *)((__privtrans->pdls[2])->data));

	PDL_LongLong * best_var_datap = ((PDL_LongLong *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_LongLong * best_var_physdatap = ((PDL_LongLong *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_F: {
	PDL_Float * y_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Float * y_physdatap = ((PDL_Float *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Float * best_avg_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Float * best_avg_physdatap = ((PDL_Float *)((__privtrans->pdls[2])->data));

	PDL_Float * best_var_datap = ((PDL_Float *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Float * best_var_physdatap = ((PDL_Float *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	} break; case PDL_D: {
	PDL_Double * y_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * y_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * best_avg_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * best_avg_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * best_var_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * best_var_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Long __inc_y_n = __privtrans->__inc_y_n;


		double S_y, S_yy, lowest_score, score, n_points, average;
		int i, best_index;
		best_index = 1;
		
			/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];y_datap += __offsp[0];
best_index_datap += __offsp[1];
best_avg_datap += __offsp[2];
best_var_datap += __offsp[3];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */

			/* first point */
			S_y = (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 0))] /* ACCESS() */ ;
			S_yy = S_y*S_y;
			
			/* second point */
			S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, 1))] /* ACCESS() */ ;
			
			/* first score */
			lowest_score = (S_yy - S_y * S_y / 2.) / 2.;
			
			/* record the average, variance, and index in case nothing later
			 * beats this one */
			(best_avg_datap)[0] /* ACCESS() */  = S_y / 2.;
			/* This is a special case: the score is the variance divided by
			 * the length, which is one in this case, so I can just use the
			 * lowest score here */
			(best_var_datap)[0] /* ACCESS() */  = lowest_score;
			(best_index_datap)[0] /* ACCESS() */  = 1;
			
			for(i = 2; i < __privtrans->__n_size; i++) {
				/* Accumulate the sums */
				S_y += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				S_yy += (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */  * (y_datap)[0+(__inc_y_n*PP_INDTERM(__privtrans->__n_size, i))] /* ACCESS() */ ;
				
				n_points = i + 1;
				
				/* Compute the score */
				score = (S_yy - S_y * S_y / n_points) / n_points / i;
				if (score < lowest_score) {
					lowest_score = score;
					(best_index_datap)[0] /* ACCESS() */  = i;
					(best_avg_datap)[0] /* ACCESS() */  = S_y / n_points;
					(best_var_datap)[0] /* ACCESS() */  = score * i;
				}
			}
			/* THREADLOOPEND */
	 y_datap += __tinc0_0;
best_index_datap += __tinc0_1;
best_avg_datap += __tinc0_2;
best_var_datap += __tinc0_3;

	 } y_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_avg_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
best_var_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;

	} y_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;best_avg_datap -= __tinc1_2 *
     				  __tdims1;best_var_datap -= __tinc1_3 *
     				  __tdims1;
 y_datap -= __offsp[0];
best_index_datap -= __offsp[1];
best_avg_datap -= __offsp[2];
best_var_datap -= __offsp[3];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 
	
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_const_min_idx_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_const_min_idx_struct *__privtrans = (pdl__MSER_const_min_idx_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl__MSER_const_min_idx_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl__MSER_const_min_idx_vtable = {
		0,0, 1, 4, pdl__MSER_const_min_idx_vtable_flags,
		pdl__MSER_const_min_idx_redodims, pdl__MSER_const_min_idx_readdata, NULL,
		pdl__MSER_const_min_idx_free,NULL,NULL,pdl__MSER_const_min_idx_copy,NULL,
		sizeof(pdl__MSER_const_min_idx_struct),"pdl__MSER_const_min_idx_vtable",
		NULL
	 };


#if 0
my $skip = <<'SKIP';
#endif

/*

=pod

=head2 Linear MSER

The basic premise for the MSER technique rests on the idea that we want to
find where the variance starts to strongly deviate from some consistent
value. We can just as easily work with the variance of the data from a
linear function as from a constant function, but care must be taken to keep
the algorithm efficient. For the linear MSER, we ask (1) what is the best
linear fit to the sequence of data up to this point, (2) how much does the
data vary with respect to that linear fit, and (3) at what point does the
MSER score, which is related to the variation scaled with respect to the
number of elements up to that point, obtain a minimum value?

=for details
The C function that I am about to define calculates the linear MSER scores
for each of a series of points. The values that it saves to memory and the
values that it uses for the x-positions depend on how you call the function.
You must provide the number of elements in your arrays (N) and the y-data
but you can pass 0 in for the x pointer as well as the scores pointer. If
you pass in zero for the x pointer, the tabulations will simply use the
increment in place of it. If you pass in an initialized array for scores, it
will store their results there; otherwise pass in a zero pointer. If you
pass in nonzero pointers for best_slope, best_intercept, or best_variance,
it will store the corresponding values at the dereferenced double. Under all
circumstances, it will return the index with the lowest score. All of this
will be explained throughout the rest of this documentation.

=cut

*/

int MSER_linear_score_calculator(double * xs, double * ys, double * scores
		, int N, double * best_slope, double * best_intercept
		, double * best_variance) {

/*

=pod

Calculating a least-squared-error linear fit for all points up to and
including the nth point is easy but I will go through the full calculation
here to make sure you know what's going on and so that I am sure all of my
equations are correct. The goal is to find the parameters that minimize this
sum:

 Sum = sum( ( Y(x_i) - y_i )^2 )

where the parameters are burried into the definition of Y(x):

 Y(x) = y0 + s * x.

Written out in full, I want to minimize this sum:

 Sum = sum( ( y0 + s * x_i - y_i )^2 )

Before going further, I will introduce a notation for the sums of the x- and
y-values:

 S_x = sum(x_i), S_xy = sum(x_i * y_i), etc.

Using this notation, the sum becomes:

 Sum = n * y0^2 + 2 * y0 * s * S_x - 2 * y0 * S_y
       + s^2 * S_xx - 2 * s * S_xy + S_yy

=for details
You can see the variable declarations for the just-named sums below, as well
as the slope and the intercept. In addition, I declare variables for x and
y, which makes a few things easier and cleaner, as well as variables to hold
the just-computed score and the overall lowest score. The variable n simply
holds the offset-plus-one, when it is used. I use the counting variable i
and store the index of the best score in the aptly named best_index
variable.

=cut

*/

	double S_x, S_y, S_xy, S_xx, S_yy, y0, s, x, y, score, lowest_score, n;
	int i, best_index;
	
	/* These are accumulators, so initialize them to zero */
	S_x = S_y = S_xx = S_xy = S_yy = 0;

	/* Compute the sums for the first three points */
	for(i = 0; i < 3; i++) {
		x = (xs ? xs[i] : i);
		y = ys[i];
		S_x += x;
		S_y += y;
		S_xy += x * y;
		S_xx += x * x;
		S_yy += y * y;
	}
	
/*

=pod

For the purposes of MSER scoring, I will declare the point that minimizes
C<Sum / n_i> to be the most likely candidate of the last point in the linear
fit. (As we will see later, C<n_i = i - 1>, as I will explain later.)

=for details
Put a bit more clearly, n_i = n_points - 2, as we'll see shortly.

To compute the value of C<y0> and C<s>, I need to take the derivative of the
squared sum with respect to the parameters C<y0> and C<s>:

 partial(sum)
 ------------ = 2 * n * y0 + 2 * s * S_x - 2 * S_y.
 partial(y0)

This needs to be set to zero, which means

 n * y0 + s * S_x - S_y = 0.

Now taking the derivative with respect to C<s> leads to this:

 partial(sum)
 ------------ = 2 * y0 * S_x + 2 * s * S_xx - 2 * S_xy
  partial(s)

which I again set to zero, obtaining

 y0 * S_x + s * S_xx - S_xy = 0.

Here are the two equations together:

 y0 * n   + s * S_x  - S_y  = 0,
 y0 * S_x + s * S_xx - S_xy = 0.

As we will see, these sums are cheap to compute and allow this method to run
in linear time. Two linear equations in two unknowns means that I can easily
compute C<y0> and C<s>. Let's first eliminate C<s> from these equations:

 y0 * n / S_x    + s - S_y / S_x   = 0,
 y0 * S_x / S_xx + s - S_xy / S_xx = 0.

Subtracting the second from the first leads to

 y0 * (n/S_x - S_x/S_xx) + S_xy/S_xx - S_y/S_x = 0,

which I can solve for C<y0> as

  ----------------------------
 |       S_y/S_x - S_xy/S_xx  |
 | y0 = --------------------- |
 |        n/S_x - S_x/S_xx    |
  ----------------------------

=cut

*/

	n = 3;
	
	/* Compute the first y-intercept */
	y0 = (S_y/S_x - S_xy/S_xx)
					/
		  (n/S_x - S_x/S_xx);
	
	/* Store the intercept, if requested */
	if (best_intercept) best_intercept[0] = y0;

/*

=pod

Once I have C<y0>, I can easily compute C<s>:

  ------------------------------
 | s = S_y / S_x - n * y0 / S_x |
  ------------------------------

=cut

*/

	/* Compute the first slope */
	s = S_y / S_x - n * y0 / S_x;
	/* Store the result if requested */
	if(best_slope) best_slope[0] = s;
	
/*

=pod

Finally, I can go back to compute the variance of the data with respect to
the fit. The variance is related to the sum that I just used to find the
parameters. Since the fit has two parameters, the number of degrees of
freedom should be C<n - 2>, where C<n> is the number of data points under
consideration. The MSER score is just this variance divided by the number of
degrees of freedom, so the score is

                      Sum
 score(n) = -----------------------
             ( n - 2 ) * ( n - 2 )

         -----------------------------------------------------------------
        |    n*y0^2 + 2*y0*s*S_x - 2*y0*S_y + s^2*S_xx - 2*s*S_xy + S_yy  |
        | = ------------------------------------------------------------- |
        |                         ( n - 2 )^2                             |
         -----------------------------------------------------------------

=cut

*/
	
	/* Compute the first score and store it, if appropriate */
	score = (n*y0*y0 + 2*y0*s*S_x - 2*y0*S_y + s*s*S_xx - 2*s*S_xy + S_yy)
			/ (n - 2) / (n - 2);
	
	lowest_score = score;
	best_index = i;
	
	if (scores) scores[0] = score;
	if (best_variance) best_variance[0] = score * (n - 2);

/*

=pod

So it is possible to compute each point's MSER for a linear fit to the data
in O(N) time, and in a single pass. I simply need to keep track of a
collection of sums, along with the minimum var/n and its corresponding index
n.

=cut

*/

	/* Loop over the remaining points */
	for(; i < N; i++) {
		x = (xs ? xs[i] : i);
		y = ys[i];
		S_x += x;
		S_y += y;
		S_xy += x * y;
		S_xx += x * x;
		S_yy += y * y;

		n = i + 1;
		
		/* Here are those equations again
		 ----------------------------
		|       S_y/S_x - S_xy/S_xx  |
		| y0 = --------------------- |
		|        n/S_x - S_x/S_xx    |
		 ----------------------------
		*/
		y0 = (S_y / S_x - S_xy / S_xx)
			/ (n / S_x - S_x / S_xx);
		/*
		 ------------------------------
		| s = S_y / S_x - n * y0 / S_x |
		 ------------------------------
		*/
		s = S_y / S_x - n * y0 / S_x;
		
		/* Compute the score and store it, as appropriate */
		/*
		 -----------------------------------------------------------------
		|    n*y0^2 + 2*y0*s*S_x - 2*y0*S_y + s^2*S_xx - 2*s*S_xy + S_yy  |
		| = ------------------------------------------------------------- |
		|                         ( n - 2 )^2                             |
		 -----------------------------------------------------------------
		*/
		score = ( n*y0*y0 + 2*y0*s*S_x - 2*y0*S_y + s*s*S_xx - 2*s*S_xy + S_yy)
				/ (n - 2) / (n - 2);
		
		if (score < lowest_score) {
			lowest_score = score;
			best_index = i;
			if(best_slope) best_slope[0] = s;
			if (best_intercept) best_intercept[0] = y0;
			if (best_variance) best_variance[0] = score * (n - 2);
		}
		
		if (scores) scores[i-2] = score;
	}
	
	return best_index;
}

#if 0
SKIP
#endif

typedef struct pdl_MSER_linear_scores_no_x_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Long  __inc_ys_n;PDL_Long  __inc_score_n2;PDL_Long  __n_size;PDL_Long  __n2_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_linear_scores_no_x_struct;

void pdl_MSER_linear_scores_no_x_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    int __creating[2];
__privtrans->__n_size = -1;
__privtrans->__n2_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;

__privtrans->__n2_size = __privtrans->pdls[0]->dims[0] - 2;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"ys","score"};
		static int __realdims[] = {1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_linear_scores_no_x";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n2_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_score_n2 = 0; else
		 __privtrans->__inc_score_n2 = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_linear_scores_no_x_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    pdl_MSER_linear_scores_no_x_struct *__copy = malloc(sizeof(pdl_MSER_linear_scores_no_x_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_ys_n=__copy->__inc_ys_n;__privtrans->__inc_score_n2=__copy->__inc_score_n2;__copy->__n_size=__privtrans->__n_size;__copy->__n2_size=__privtrans->__n2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_linear_scores_no_x_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];ys_datap += __offsp[0];
score_datap += __offsp[1];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;


		MSER_linear_score_calculator(0, ys_datap, score_datap, __privtrans->__n_size, 0, 0, 0);
	
}	/* THREADLOOPEND */
	 ys_datap += __tinc0_0;
score_datap += __tinc0_1;

	 } ys_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
score_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;

	} ys_datap -= __tinc1_0 *
     				  __tdims1;score_datap -= __tinc1_1 *
     				  __tdims1;
 ys_datap -= __offsp[0];
score_datap -= __offsp[1];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_linear_scores_no_x_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_no_x_struct *__privtrans = (pdl_MSER_linear_scores_no_x_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_MSER_linear_scores_no_x_vtable_flags[] =
	 	{ 0,0};
	 pdl_transvtable pdl_MSER_linear_scores_no_x_vtable = {
		0,0, 1, 2, pdl_MSER_linear_scores_no_x_vtable_flags,
		pdl_MSER_linear_scores_no_x_redodims, pdl_MSER_linear_scores_no_x_readdata, NULL,
		pdl_MSER_linear_scores_no_x_free,NULL,NULL,pdl_MSER_linear_scores_no_x_copy,NULL,
		sizeof(pdl_MSER_linear_scores_no_x_struct),"pdl_MSER_linear_scores_no_x_vtable",
		NULL
	 };

typedef struct pdl_MSER_linear_scores_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Long  __inc_xs_n;PDL_Long  __inc_ys_n;PDL_Long  __inc_score_n2;PDL_Long  __n_size;PDL_Long  __n2_size;
		
		char __ddone; /* Dims done */
		} pdl_MSER_linear_scores_struct;

void pdl_MSER_linear_scores_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    int __creating[3];
__privtrans->__n_size = -1;
__privtrans->__n2_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;

__privtrans->__n2_size = __privtrans->pdls[1]->dims[0] - 2;
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"xs","ys","score"};
		static int __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Regex::MSER::MSER_linear_scores";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in MSER_linear_scores:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[2]; /* Use ninds+1 to avoid smart (stupid) compilers */dims[0] = __privtrans->__n2_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xs_n = 0; else
		 __privtrans->__inc_xs_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_score_n2 = 0; else
		 __privtrans->__inc_score_n2 = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_MSER_linear_scores_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    pdl_MSER_linear_scores_struct *__copy = malloc(sizeof(pdl_MSER_linear_scores_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xs_n=__copy->__inc_xs_n;__privtrans->__inc_ys_n=__copy->__inc_ys_n;__privtrans->__inc_score_n2=__copy->__inc_score_n2;__copy->__n_size=__privtrans->__n_size;__copy->__n2_size=__privtrans->__n2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_MSER_linear_scores_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * score_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * score_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];xs_datap += __offsp[0];
ys_datap += __offsp[1];
score_datap += __offsp[2];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_score_n2 = __privtrans->__inc_score_n2;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;


		MSER_linear_score_calculator(xs_datap, ys_datap, score_datap, __privtrans->__n_size, 0, 0, 0);
	
}	/* THREADLOOPEND */
	 xs_datap += __tinc0_0;
ys_datap += __tinc0_1;
score_datap += __tinc0_2;

	 } xs_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ys_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
score_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;

	} xs_datap -= __tinc1_0 *
     				  __tdims1;ys_datap -= __tinc1_1 *
     				  __tdims1;score_datap -= __tinc1_2 *
     				  __tdims1;
 xs_datap -= __offsp[0];
ys_datap -= __offsp[1];
score_datap -= __offsp[2];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_MSER_linear_scores_free(pdl_trans *__tr ) {
	int __dim;
	pdl_MSER_linear_scores_struct *__privtrans = (pdl_MSER_linear_scores_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_MSER_linear_scores_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_MSER_linear_scores_vtable = {
		0,0, 2, 3, pdl_MSER_linear_scores_vtable_flags,
		pdl_MSER_linear_scores_redodims, pdl_MSER_linear_scores_readdata, NULL,
		pdl_MSER_linear_scores_free,NULL,NULL,pdl_MSER_linear_scores_copy,NULL,
		sizeof(pdl_MSER_linear_scores_struct),"pdl_MSER_linear_scores_vtable",
		NULL
	 };

typedef struct pdl__MSER_linear_min_idx_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Long  __inc_xs_n;PDL_Long  __inc_ys_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_linear_min_idx_struct;

void pdl__MSER_linear_min_idx_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    int __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"xs","ys","best_index","slope","intercept","variance"};
		static int __realdims[] = {1,1,0,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_linear_min_idx";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[2]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_xs_n = 0; else
		 __privtrans->__inc_xs_n = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[1]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_linear_min_idx_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    pdl__MSER_linear_min_idx_struct *__copy = malloc(sizeof(pdl__MSER_linear_min_idx_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_xs_n=__copy->__inc_xs_n;__privtrans->__inc_ys_n=__copy->__inc_ys_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_linear_min_idx_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * xs_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * xs_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * slope_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * slope_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * intercept_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * intercept_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * variance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * variance_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc0_5 = __privtrans->__pdlthread.incs[5];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];register int __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];xs_datap += __offsp[0];
ys_datap += __offsp[1];
best_index_datap += __offsp[2];
slope_datap += __offsp[3];
intercept_datap += __offsp[4];
variance_datap += __offsp[5];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;
register PDL_Long __inc_xs_n = __privtrans->__inc_xs_n;


		(best_index_datap)[0] /* ACCESS() */  = MSER_linear_score_calculator(xs_datap, ys_datap, 0, __privtrans->__n_size
				, slope_datap, intercept_datap, variance_datap);
	
}	/* THREADLOOPEND */
	 xs_datap += __tinc0_0;
ys_datap += __tinc0_1;
best_index_datap += __tinc0_2;
slope_datap += __tinc0_3;
intercept_datap += __tinc0_4;
variance_datap += __tinc0_5;

	 } xs_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
ys_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
best_index_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
slope_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
intercept_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;
variance_datap += __tinc1_5
	     			     - __tinc0_5 *
				       __tdims0;

	} xs_datap -= __tinc1_0 *
     				  __tdims1;ys_datap -= __tinc1_1 *
     				  __tdims1;best_index_datap -= __tinc1_2 *
     				  __tdims1;slope_datap -= __tinc1_3 *
     				  __tdims1;intercept_datap -= __tinc1_4 *
     				  __tdims1;variance_datap -= __tinc1_5 *
     				  __tdims1;
 xs_datap -= __offsp[0];
ys_datap -= __offsp[1];
best_index_datap -= __offsp[2];
slope_datap -= __offsp[3];
intercept_datap -= __offsp[4];
variance_datap -= __offsp[5];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_linear_min_idx_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_struct *__privtrans = (pdl__MSER_linear_min_idx_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;
			}
			
	}
    }
    



static char pdl__MSER_linear_min_idx_vtable_flags[] =
	 	{ 0,0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl__MSER_linear_min_idx_vtable = {
		0,0, 2, 6, pdl__MSER_linear_min_idx_vtable_flags,
		pdl__MSER_linear_min_idx_redodims, pdl__MSER_linear_min_idx_readdata, NULL,
		pdl__MSER_linear_min_idx_free,NULL,NULL,pdl__MSER_linear_min_idx_copy,NULL,
		sizeof(pdl__MSER_linear_min_idx_struct),"pdl__MSER_linear_min_idx_vtable",
		NULL
	 };

typedef struct pdl__MSER_linear_min_idx_no_x_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Long  __inc_ys_n;PDL_Long  __n_size;
		
		char __ddone; /* Dims done */
		} pdl__MSER_linear_min_idx_no_x_struct;

void pdl__MSER_linear_min_idx_no_x_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    int __creating[5];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
/* no RedoDimsCode */
}
 {
 static char *__parnames[] = {"ys","best_index","slope","intercept","variance"};
		static int __realdims[] = {1,0,0,0,0};
		static char __funcname[] = "PDL::Regex::MSER::_MSER_linear_min_idx_no_x";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in _MSER_linear_min_idx_no_x:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 int dims[1]; /* Use ninds+1 to avoid smart (stupid) compilers */
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ /* convenience block */
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  /* Call the perl routine _hdr_copy... */
    int count;
    /* Call the perl routine PDL::_hdr_copy(hdrp) */
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef)
       SvREFCNT_inc(hdr_copy); /*Keep hdr_copy from vanishing during FREETMPS*/

    FREETMPS ;
    LEAVE ;


  } /* end of callback  block */

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
    if(hdr_copy != &PL_sv_undef) 
      SvREFCNT_dec(hdr_copy); /* make hdr_copy mortal again */
   } /* end of if(hdrp) block */
} /* end of conv. block */
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_ys_n = 0; else
		 __privtrans->__inc_ys_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl__MSER_linear_min_idx_no_x_copy(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    pdl__MSER_linear_min_idx_no_x_struct *__copy = malloc(sizeof(pdl__MSER_linear_min_idx_no_x_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_ys_n=__copy->__inc_ys_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl__MSER_linear_min_idx_no_x_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    {/* Start generic loop */

	switch(__privtrans->__datatype) { case -42: /* Warning eater */ {1;
	} break; case PDL_D: {
	PDL_Double * ys_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * ys_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * best_index_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * best_index_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * slope_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * slope_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * intercept_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * intercept_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * variance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * variance_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	/* THREADLOOPBEGIN */
 if(PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata,
 	__tr)) return;
   do { register int __tind1=0,__tind2=0;
        register int __tnpdls = __privtrans->__pdlthread.npdls;
      register int __tdims1 = __privtrans->__pdlthread.dims[1];
      register int __tdims0 = __privtrans->__pdlthread.dims[0];
      register int *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
 register int __tinc0_0 = __privtrans->__pdlthread.incs[0];register int __tinc0_1 = __privtrans->__pdlthread.incs[1];register int __tinc0_2 = __privtrans->__pdlthread.incs[2];register int __tinc0_3 = __privtrans->__pdlthread.incs[3];register int __tinc0_4 = __privtrans->__pdlthread.incs[4];register int __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];register int __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];register int __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];register int __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];register int __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];ys_datap += __offsp[0];
best_index_datap += __offsp[1];
slope_datap += __offsp[2];
intercept_datap += __offsp[3];
variance_datap += __offsp[4];

	for(__tind2=0; __tind2<__tdims1 ; __tind2++) {
	 for(__tind1=0; __tind1<__tdims0 ; __tind1++) {
	  /* This is the tightest threadloop. Make sure inside is optimal. */
{register PDL_Long __inc_ys_n = __privtrans->__inc_ys_n;


		(best_index_datap)[0] /* ACCESS() */  = MSER_linear_score_calculator(0, ys_datap, 0, __privtrans->__n_size
				, slope_datap, intercept_datap, variance_datap);
	
}	/* THREADLOOPEND */
	 ys_datap += __tinc0_0;
best_index_datap += __tinc0_1;
slope_datap += __tinc0_2;
intercept_datap += __tinc0_3;
variance_datap += __tinc0_4;

	 } ys_datap += __tinc1_0
	     			     - __tinc0_0 *
				       __tdims0;
best_index_datap += __tinc1_1
	     			     - __tinc0_1 *
				       __tdims0;
slope_datap += __tinc1_2
	     			     - __tinc0_2 *
				       __tdims0;
intercept_datap += __tinc1_3
	     			     - __tinc0_3 *
				       __tdims0;
variance_datap += __tinc1_4
	     			     - __tinc0_4 *
				       __tdims0;

	} ys_datap -= __tinc1_0 *
     				  __tdims1;best_index_datap -= __tinc1_1 *
     				  __tdims1;slope_datap -= __tinc1_2 *
     				  __tdims1;intercept_datap -= __tinc1_3 *
     				  __tdims1;variance_datap -= __tinc1_4 *
     				  __tdims1;
 ys_datap -= __offsp[0];
best_index_datap -= __offsp[1];
slope_datap -= __offsp[2];
intercept_datap -= __offsp[3];
variance_datap -= __offsp[4];

      } while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
 	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl__MSER_linear_min_idx_no_x_free(pdl_trans *__tr ) {
	int __dim;
	pdl__MSER_linear_min_idx_no_x_struct *__privtrans = (pdl__MSER_linear_min_idx_no_x_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl__MSER_linear_min_idx_no_x_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl__MSER_linear_min_idx_no_x_vtable = {
		0,0, 1, 5, pdl__MSER_linear_min_idx_no_x_vtable_flags,
		pdl__MSER_linear_min_idx_no_x_redodims, pdl__MSER_linear_min_idx_no_x_readdata, NULL,
		pdl__MSER_linear_min_idx_no_x_free,NULL,NULL,pdl__MSER_linear_min_idx_no_x_copy,NULL,
		sizeof(pdl__MSER_linear_min_idx_no_x_struct),"pdl__MSER_linear_min_idx_no_x_vtable",
		NULL
	 };



MODULE = PDL::Regex::MSER PACKAGE = PDL::Regex::MSER

PROTOTYPES: ENABLE

int
set_debugging(i)
	int i;
	CODE:
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
	OUTPUT:
	RETVAL

int
set_boundscheck(i)
       int i;
       CODE:
       if (! 1)
         warn("Bounds checking is disabled for PDL::Regex::MSER");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
       OUTPUT:
       RETVAL


MODULE = PDL::Regex::MSER PACKAGE = PDL


void
MSER_const_scores(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *scores_SV;
  pdl  *y;
  pdl  *scores;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    y = PDL->SvPDLV(ST(0));
    scores = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    y = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       scores_SV = sv_newmortal();
       scores = PDL->null();
       PDL->SetSV_PDL(scores_SV,scores);
       if (bless_stash) scores_SV = sv_bless(scores_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       scores_SV = POPs;
       PUTBACK;
       scores = PDL->SvPDLV(scores_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_const_scores(y,scores) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_const_scores_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_const_scores_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((scores->state & PDL_NOMYDIMS) &&
		       scores->trans == NULL) && __privtrans->__datatype < scores->datatype) {
		 	__privtrans->__datatype = scores->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (scores->state & PDL_NOMYDIMS) && scores->trans == NULL ) {
	     scores->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != scores->datatype) {
	     scores = PDL->get_convertedpdl(scores,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = y;
__privtrans->pdls[1] = scores;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  scores->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = scores_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
_MSER_const_min_idx(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *best_avg_SV;
  SV *best_var_SV;
  pdl  *y;
  pdl  *best_index;
  pdl  *best_avg;
  pdl  *best_var;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 4) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    y = PDL->SvPDLV(ST(0));
    best_index = PDL->SvPDLV(ST(1));
    best_avg = PDL->SvPDLV(ST(2));
    best_var = PDL->SvPDLV(ST(3));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 3;
    y = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_avg_SV = sv_newmortal();
       best_avg = PDL->null();
       PDL->SetSV_PDL(best_avg_SV,best_avg);
       if (bless_stash) best_avg_SV = sv_bless(best_avg_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_avg_SV = POPs;
       PUTBACK;
       best_avg = PDL->SvPDLV(best_avg_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_var_SV = sv_newmortal();
       best_var = PDL->null();
       PDL->SetSV_PDL(best_var_SV,best_var);
       if (bless_stash) best_var_SV = sv_bless(best_var_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_var_SV = POPs;
       PUTBACK;
       best_var = PDL->SvPDLV(best_var_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_const_min_idx(y,best_index,best_avg,best_var) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_const_min_idx_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_const_min_idx_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((y->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < y->datatype) {
		 	__privtrans->__datatype = y->datatype;
		    }
if(!((best_avg->state & PDL_NOMYDIMS) &&
		       best_avg->trans == NULL) && __privtrans->__datatype < best_avg->datatype) {
		 	__privtrans->__datatype = best_avg->datatype;
		    }
if(!((best_var->state & PDL_NOMYDIMS) &&
		       best_var->trans == NULL) && __privtrans->__datatype < best_var->datatype) {
		 	__privtrans->__datatype = best_var->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != y->datatype) {
	     y = PDL->get_convertedpdl(y,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (best_avg->state & PDL_NOMYDIMS) && best_avg->trans == NULL ) {
	     best_avg->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != best_avg->datatype) {
	     best_avg = PDL->get_convertedpdl(best_avg,__privtrans->__datatype);
	  }if( (best_var->state & PDL_NOMYDIMS) && best_var->trans == NULL ) {
	     best_var->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != best_var->datatype) {
	     best_var = PDL->get_convertedpdl(best_var,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = y;
__privtrans->pdls[1] = best_index;
__privtrans->pdls[2] = best_avg;
__privtrans->pdls[3] = best_var;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  best_avg->state |= PDL_BADVAL;
  best_var->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = best_avg_SV;
  ST(2) = best_var_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
MSER_linear_scores_no_x(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *score_SV;
  pdl  *ys;
  pdl  *score;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 2) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    ys = PDL->SvPDLV(ST(0));
    score = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    ys = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       score_SV = sv_newmortal();
       score = PDL->null();
       PDL->SetSV_PDL(score_SV,score);
       if (bless_stash) score_SV = sv_bless(score_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       score_SV = POPs;
       PUTBACK;
       score = PDL->SvPDLV(score_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_linear_scores_no_x(ys,score) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_linear_scores_no_x_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_linear_scores_no_x_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((score->state & PDL_NOMYDIMS) &&
		       score->trans == NULL) && __privtrans->__datatype < score->datatype) {
		 	__privtrans->__datatype = score->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (score->state & PDL_NOMYDIMS) && score->trans == NULL ) {
	     score->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != score->datatype) {
	     score = PDL->get_convertedpdl(score,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ys;
__privtrans->pdls[1] = score;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  score->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = score_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
MSER_linear_scores(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *score_SV;
  pdl  *xs;
  pdl  *ys;
  pdl  *score;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 3) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    score = PDL->SvPDLV(ST(2));
  }
  else if (items == 2) { /* only input variables on stack, create outputs and temps */
    nreturn = 1;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       score_SV = sv_newmortal();
       score = PDL->null();
       PDL->SetSV_PDL(score_SV,score);
       if (bless_stash) score_SV = sv_bless(score_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       score_SV = POPs;
       PUTBACK;
       score = PDL->SvPDLV(score_SV);
    }
  }
  else {
    croak ("Usage:  PDL::MSER_linear_scores(xs,ys,score) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_MSER_linear_scores_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_MSER_linear_scores_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xs->state & PDL_BADVAL) > 0) || ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xs->datatype) {
		 	__privtrans->__datatype = xs->datatype;
		    }
if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((score->state & PDL_NOMYDIMS) &&
		       score->trans == NULL) && __privtrans->__datatype < score->datatype) {
		 	__privtrans->__datatype = score->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xs->datatype) {
	     xs = PDL->get_convertedpdl(xs,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (score->state & PDL_NOMYDIMS) && score->trans == NULL ) {
	     score->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != score->datatype) {
	     score = PDL->get_convertedpdl(score,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xs;
__privtrans->pdls[1] = ys;
__privtrans->pdls[2] = score;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  score->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = score_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
_MSER_linear_min_idx(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *slope_SV;
  SV *intercept_SV;
  SV *variance_SV;
  pdl  *xs;
  pdl  *ys;
  pdl  *best_index;
  pdl  *slope;
  pdl  *intercept;
  pdl  *variance;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 6) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    best_index = PDL->SvPDLV(ST(2));
    slope = PDL->SvPDLV(ST(3));
    intercept = PDL->SvPDLV(ST(4));
    variance = PDL->SvPDLV(ST(5));
  }
  else if (items == 2) { /* only input variables on stack, create outputs and temps */
    nreturn = 4;
    xs = PDL->SvPDLV(ST(0));
    ys = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       slope_SV = sv_newmortal();
       slope = PDL->null();
       PDL->SetSV_PDL(slope_SV,slope);
       if (bless_stash) slope_SV = sv_bless(slope_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       slope_SV = POPs;
       PUTBACK;
       slope = PDL->SvPDLV(slope_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       intercept_SV = sv_newmortal();
       intercept = PDL->null();
       PDL->SetSV_PDL(intercept_SV,intercept);
       if (bless_stash) intercept_SV = sv_bless(intercept_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       intercept_SV = POPs;
       PUTBACK;
       intercept = PDL->SvPDLV(intercept_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       variance_SV = sv_newmortal();
       variance = PDL->null();
       PDL->SetSV_PDL(variance_SV,variance);
       if (bless_stash) variance_SV = sv_bless(variance_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       variance_SV = POPs;
       PUTBACK;
       variance = PDL->SvPDLV(variance_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_linear_min_idx(xs,ys,best_index,slope,intercept,variance) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_linear_min_idx_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_linear_min_idx_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((xs->state & PDL_BADVAL) > 0) || ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < xs->datatype) {
		 	__privtrans->__datatype = xs->datatype;
		    }
if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((slope->state & PDL_NOMYDIMS) &&
		       slope->trans == NULL) && __privtrans->__datatype < slope->datatype) {
		 	__privtrans->__datatype = slope->datatype;
		    }
if(!((intercept->state & PDL_NOMYDIMS) &&
		       intercept->trans == NULL) && __privtrans->__datatype < intercept->datatype) {
		 	__privtrans->__datatype = intercept->datatype;
		    }
if(!((variance->state & PDL_NOMYDIMS) &&
		       variance->trans == NULL) && __privtrans->__datatype < variance->datatype) {
		 	__privtrans->__datatype = variance->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != xs->datatype) {
	     xs = PDL->get_convertedpdl(xs,__privtrans->__datatype);
	  }if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (slope->state & PDL_NOMYDIMS) && slope->trans == NULL ) {
	     slope->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != slope->datatype) {
	     slope = PDL->get_convertedpdl(slope,__privtrans->__datatype);
	  }if( (intercept->state & PDL_NOMYDIMS) && intercept->trans == NULL ) {
	     intercept->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != intercept->datatype) {
	     intercept = PDL->get_convertedpdl(intercept,__privtrans->__datatype);
	  }if( (variance->state & PDL_NOMYDIMS) && variance->trans == NULL ) {
	     variance->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != variance->datatype) {
	     variance = PDL->get_convertedpdl(variance,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = xs;
__privtrans->pdls[1] = ys;
__privtrans->pdls[2] = best_index;
__privtrans->pdls[3] = slope;
__privtrans->pdls[4] = intercept;
__privtrans->pdls[5] = variance;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  slope->state |= PDL_BADVAL;
  intercept->state |= PDL_BADVAL;
  variance->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = slope_SV;
  ST(2) = intercept_SV;
  ST(3) = variance_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}

void
_MSER_linear_min_idx_no_x(...)
 PREINIT:
  char *objname = "PDL"; /* maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *best_index_SV;
  SV *slope_SV;
  SV *intercept_SV;
  SV *variance_SV;
  pdl  *ys;
  pdl  *best_index;
  pdl  *slope;
  pdl  *intercept;
  pdl  *variance;
 PPCODE:
{
  /* Check if you can get a package name for this input value.  It can be either a PDL (SVt_PVMG) or
     a hash which is a derived PDL subclass (SVt_PVHV) */
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent))
      objname = HvNAME((bless_stash = SvSTASH(SvRV(ST(0)))));  /* The package to bless output vars into is taken from the first input var */
  }
  if (items == 5) { /* all variables on stack, read in output and temp vars */
    nreturn = 0;
    ys = PDL->SvPDLV(ST(0));
    best_index = PDL->SvPDLV(ST(1));
    slope = PDL->SvPDLV(ST(2));
    intercept = PDL->SvPDLV(ST(3));
    variance = PDL->SvPDLV(ST(4));
  }
  else if (items == 1) { /* only input variables on stack, create outputs and temps */
    nreturn = 4;
    ys = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       best_index_SV = sv_newmortal();
       best_index = PDL->null();
       PDL->SetSV_PDL(best_index_SV,best_index);
       if (bless_stash) best_index_SV = sv_bless(best_index_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       best_index_SV = POPs;
       PUTBACK;
       best_index = PDL->SvPDLV(best_index_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       slope_SV = sv_newmortal();
       slope = PDL->null();
       PDL->SetSV_PDL(slope_SV,slope);
       if (bless_stash) slope_SV = sv_bless(slope_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       slope_SV = POPs;
       PUTBACK;
       slope = PDL->SvPDLV(slope_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       intercept_SV = sv_newmortal();
       intercept = PDL->null();
       PDL->SetSV_PDL(intercept_SV,intercept);
       if (bless_stash) intercept_SV = sv_bless(intercept_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       intercept_SV = POPs;
       PUTBACK;
       intercept = PDL->SvPDLV(intercept_SV);
    }
    if (strcmp(objname,"PDL") == 0) { /* shortcut if just PDL */
       variance_SV = sv_newmortal();
       variance = PDL->null();
       PDL->SetSV_PDL(variance_SV,variance);
       if (bless_stash) variance_SV = sv_bless(variance_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       variance_SV = POPs;
       PUTBACK;
       variance = PDL->SvPDLV(variance_SV);
    }
  }
  else {
    croak ("Usage:  PDL::_MSER_linear_min_idx_no_x(ys,best_index,slope,intercept,variance) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl__MSER_linear_min_idx_no_x_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl__MSER_linear_min_idx_no_x_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((ys->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < ys->datatype) {
		 	__privtrans->__datatype = ys->datatype;
		    }
if(!((slope->state & PDL_NOMYDIMS) &&
		       slope->trans == NULL) && __privtrans->__datatype < slope->datatype) {
		 	__privtrans->__datatype = slope->datatype;
		    }
if(!((intercept->state & PDL_NOMYDIMS) &&
		       intercept->trans == NULL) && __privtrans->__datatype < intercept->datatype) {
		 	__privtrans->__datatype = intercept->datatype;
		    }
if(!((variance->state & PDL_NOMYDIMS) &&
		       variance->trans == NULL) && __privtrans->__datatype < variance->datatype) {
		 	__privtrans->__datatype = variance->datatype;
		    }
if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(__privtrans->__datatype != ys->datatype) {
	     ys = PDL->get_convertedpdl(ys,__privtrans->__datatype);
	  }if( (best_index->state & PDL_NOMYDIMS) && best_index->trans == NULL ) {
	     best_index->datatype = PDL_L;
	  } else if(PDL_L != best_index->datatype) {
	     best_index = PDL->get_convertedpdl(best_index,PDL_L);
	  }if( (slope->state & PDL_NOMYDIMS) && slope->trans == NULL ) {
	     slope->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != slope->datatype) {
	     slope = PDL->get_convertedpdl(slope,__privtrans->__datatype);
	  }if( (intercept->state & PDL_NOMYDIMS) && intercept->trans == NULL ) {
	     intercept->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != intercept->datatype) {
	     intercept = PDL->get_convertedpdl(intercept,__privtrans->__datatype);
	  }if( (variance->state & PDL_NOMYDIMS) && variance->trans == NULL ) {
	     variance->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != variance->datatype) {
	     variance = PDL->get_convertedpdl(variance,__privtrans->__datatype);
	  }{}/* No flow */__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = ys;
__privtrans->pdls[1] = best_index;
__privtrans->pdls[2] = slope;
__privtrans->pdls[3] = intercept;
__privtrans->pdls[4] = variance;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  best_index->state |= PDL_BADVAL;
  slope->state |= PDL_BADVAL;
  intercept->state |= PDL_BADVAL;
  variance->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = best_index_SV;
  ST(1) = slope_SV;
  ST(2) = intercept_SV;
  ST(3) = variance_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}


BOOT:

   /* Get pointer to structure of core shared C routines */
   /* make sure PDL::Core is loaded */
   perl_require_pv("PDL::Core");
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
#ifndef aTHX_
#define aTHX_
#endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "Can't load PDL::Core module");
   PDL = INT2PTR(Core*, SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] PDL::Regex::MSER needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);
         
